robot description: stessa struttura ->
- launch: upload.launch -> base dei launch: genera urdf dallo xacro in base agli argomenti che gli diamo (arg), poi il launch carica nel param server alcuni parametri (param)
          rviz.launch -> lancia upload.launch, importante joint state publisher gui (sliders) pubblica gli state che vengono trasformati in tf
          ur5.launch -> per lanciare la simulazione ho bisogno di: robot_description (caricato nel param server da upload) con il tag <include>
                        lanciare gazebo con include (gz_server è il motore che deve sempre andare, il gz_client è la gui che è opzionale)
                        bisogna spawnare il robot: chiamta a gazebo_ros con spawn_model 
                        controllori:
                        - dal pkg controller_manager, lancia ros_impedance_controller che lancia due "controllori", uno joint_state_publisher per far comunicare ros e gazebo,
                          l'altro è il controller effettivo per far muovere il robot
                        - rosparam: legge un yaml file e mette sul parameter server: joint state pulbiser -> frequenza di pubblicazione e il tipo, ros_impedance_controller mettimamo 
                          i nomi dei joint e i guadagni e home ()
                        - robot state publisher: converte gli state publisher nel frame voluto
                        - controller: (pkg ros_control): ros_init (legge i pid da config file, prendere i comandi e passarli a gazebo, modificare i pid a runtime), 
                           update (per effort control -> implemento proprio il controllo PID, con set_comand -> pubblico quello che deve fare il robot)
                        - hardware interface: 
                        - 
